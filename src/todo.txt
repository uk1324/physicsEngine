Editor
Evaluating expressions in ImGui inputs. Could also include access to variables.
Sequencer system for cutscenes. Triggers, Camera panning action
The scene hierarchy should be a seperate part of the file format. Entites should still be stored in arrays.
This makes it easier to remove it from the final file and also import it is easier.
Chain editor. Half spaces or lines?
Proceduraly generating textures under the chain.

Modifiers
In the editor could store a map<Entity, Modifier>.

Modifiers a just functions that are updated every frame and get the entity as the input.
They could be used to make motors(set velocity of something). Could also integrate a scripting language for making more complicated scripts.

Maybe add a unit type system for the langage. mass * length = velocity

To generatae angles of a convex poylgon could generate a sum of angles that are less than 90 and then normalize it.
These ides wouldn't work, but are cool. Generating a point on a sphere. Angles or generate on cube and then normalize.

.data
Store an array of structs with enum + index that specifes the order in which thing code should be generated.

Maybe make a immediate mode style interface for the editor.
if (Circle(&pos)) {

}

Create a scoped std::ostream that writes tabs on a newline. 

Make things like this not happen.
	result["staticWorldSpaceAnchorOrBodyAnchorB"] = 	if (const auto value = std::get_if<Vec2>(&staticWorldSpaceAnchorOrBodyAnchorB)){
		{ { "type", Vec2 }, 
		{ { "value", { { "x", staticWorldSpaceAnchorOrBodyAnchorB.x }, { "y", staticWorldSpaceAnchorOrBodyAnchorB.y } } }
	 }
;

Snap the passed cursor pos to important features like corners

Have a menu that allows saving sublevels something similar to prefabs in unity. And maybe make creating things like shapes only be a tab in the menu for those things.

Maybe make a menu appear when two entities are selected that shows that they can be connected with a joint. Maybe show the menu only after something is held down for some amount of time.

For modifiers store a map of entiy to modifier. Maybe also store the entity in the modifier so the it knows it should and or remove itself from the list.

Distance joint modifier that changes the distance.

// https://developer.valvesoftware.com/wiki/Physics_Entities_on_Server_%26_Client
Collision groups. Group zero means collide with everything. When loading a level could check what groups are already used. Could have an option to color things in different groups differently. Could make making things static by making the group they are in static. Or maybe just something like static groups idk. Groups could either be represented by numbers or colors.
A better way to implement this would be to have collision layers. Collision groups would define which layers can collide with eachother. Relational database. Custom gui for selecting the collision layer of body. Could allow naming layers and the gui could display the names. It would probably be better to call it after calling the gui method of the object because it needs to access the names of the collision layers and passing that into a function would require some modifications.
Either store pairs or for each layer store an list. Creating a kind of matrix.
NoCollisionConstraint 

Maybe make a controallble camera that can be used in different parts of the engine. Maybe make some features disabable like grabbing.

Maybe make adding things like joints separate tools. If they are selected then when a body is clicked a joint is started when another one is the joint ends.

Read about more generic seraizliation systems. Versioning. When adding a new field assign which version it belongs to. This would allow binary loading of data.

When drawing colliders could save the velocitites and use hermite interpolation.

Select brush

Make the entity system immediate mode. Callbacks seem more error prone. 
Control the entity access with optional types (this could also be done in a callback system, but then you are doing twice the work). Having to always check that the entity is alive seems like a good idea. Deleting entites can also be done in an immediate way. The acceleration structures could just check if the entites it stores are alive. There is no need to store a list of removed entites because the indexes can't get invalidated.
Adding entites can invalidate references. So to avoid mistakes it is probably better to buffer it.
In my previous entity systems the order of the entites could change when deleting so the deletion had to be delayed to the end of the frame.

Read particle dynamics again
https://www.cs.cmu.edu/~baraff/sigcourse/

When interpolating between 2 signed distance fields the colors should also be interpolated. Interpolating between colors might look better when interpolating between the curves.

Gauss sidel is a method for solving systems of equations.
In the case of a linear system of equations the process looks like this.
Frist select some random initial values.
Solve the first equation for the first unknown. Pass the value to the subsequent equations and repeat with the other equations.
This method doesn't always converge.
The solutions to a linear system of equations can be interpreted as an intersection of n hyperplanes.
Soultions of each equation represents a plane. The gauss seidel method esentially projects (shortest distance) a random point onto the subsequent planes. This often gets coloser to the point of intersection of the hyperplanes.